---
description: React and Next.js component patterns and best practices
globs: **/*.{tsx,jsx}
alwaysApply: false
---

# React Component Patterns

React and Next.js specific patterns for the Artemis project.

## Component Structure

### Functional Components
Always use functional components with TypeScript:

```typescript
// ✅ GOOD
interface ProjectListErrorProps {
  onRetry: () => void;
}

export const ProjectListError = ({ onRetry }: ProjectListErrorProps) => {
  return (
    <div>
      <button onClick={onRetry}>Try Again</button>
    </div>
  );
};

// ❌ BAD - Class components
export class ProjectListError extends React.Component {
  // Don't use class components
}
```

## Conditional Rendering

### Use RenderIf Component
```typescript
// ✅ GOOD - Clean and readable
<RenderIf
  condition={isLoading}
  render={<LoadingSkeleton />}
/>

<RenderIf
  condition={hasProjects}
  render={
    <>
      {projects.map(project => (
        <ProjectCard key={project.id} project={project} />
      ))}
    </>
  }
/>

// ❌ BAD - Messy ternaries
{isLoading ? <LoadingSkeleton /> : null}
{isError ? <ErrorMessage /> : hasProjects ? <ProjectList /> : <EmptyState />}
```

## Lists and Keys

### Never use array index as key

Using the array index as `key` causes bugs when the list reorders, and can break component state and performance. Always use a **stable, unique identifier** from the data, or predefined stable keys for static/placeholder lists.

```typescript
// ✅ GOOD - Use unique id from data
{projects.map((project) => (
  <ProjectCard key={project.id} project={project} />
))}

{items.map((item) => (
  <ItemRow key={item.uuid} item={item} />
))}

// ✅ GOOD - Static/placeholder list: use predefined stable keys (not index)
const SKELETON_KEYS = ["skeleton-a", "skeleton-b", "skeleton-c"] as const;
{SKELETON_KEYS.map((key) => (
  <SkeletonCard key={key} />
))}

// ❌ BAD - Using array index as key
{items.map((item, index) => (
  <ItemRow key={index} item={item} />
))}
{Array.from({ length: 5 }).map((_, i) => (
  <Placeholder key={i} />
))}
{list.map((x, idx) => (
  <div key={`row-${idx}`}>...</div>
))}
```

### Why avoid index as key?

- **Reordering**: If the list is reordered, React reuses DOM by key. With index keys, components get wrong props and state is mixed up.
- **Performance**: React can't correctly reconcile which item moved; it may re-render or unmount/remount incorrectly.
- **State bugs**: Input focus, selection, or local state can "stick" to the wrong item after reorder or filter.

### How to fix when you don't have an id

1. **Data from API**: Prefer `item.id`, `item.uuid`, or another unique field from the backend.
2. **Static placeholder/skeleton lists**: Define a constant array of stable string keys and iterate over it (e.g. `["skeleton-a", "skeleton-b", "skeleton-c"]`), then use `key={key}`.
3. **Generated list that never reorders**: If the list is truly static and will never reorder, you can use a stable key generator (e.g. `key={\`item-${item.name}\`}` only if `name` is unique). Prefer a real id when available.

## State Management

### React Query for Server State
```typescript
// ✅ GOOD - Use React Query hooks
export function useGetAllProjects() {
  const { data, isError, isFetching, refetch } = useQuery({
    queryKey: QUERY_KEYS.PROJECTS.ALL,
    queryFn: getAllProjects,
  });

  return {
    projects: data || [],
    isErrorProjects: isError,
    isFetchingProjects: isFetching,
    refetchProjects: refetch,
  };
}
```

### Local UI State
```typescript
// ✅ GOOD - useState for local UI
const [isOpen, setIsOpen] = useState(false);
const [selectedProject, setSelectedProject] = useState<Project | null>(null);
```

## Loading & Error States

Always handle all states explicitly:

```typescript
// ✅ GOOD - All states covered
export function ProjectsList() {
  const { projects, isError, isLoading, refetch } = useGetAllProjects();

  const shouldShowList = !isLoading && !isError && projects.length > 0;
  const shouldShowEmpty = !isLoading && !isError && projects.length === 0;

  return (
    <>
      <RenderIf condition={isLoading} render={<LoadingSkeleton />} />
      <RenderIf condition={isError} render={<ErrorState onRetry={refetch} />} />
      <RenderIf condition={shouldShowEmpty} render={<EmptyState />} />
      <RenderIf condition={shouldShowList} render={<List items={projects} />} />
    </>
  );
}
```

## Component Organization

### Extract Sub-components
When a component grows beyond 150 lines, extract parts into sub-components:

```typescript
// ✅ GOOD - Extracted into separate files
import { ProjectListSkeleton } from "@/view/components/project-list-skeleton";
import { ProjectListError } from "@/view/components/project-list-error";
import { ProjectListEmpty } from "@/view/components/project-list-empty";

// Each component in its own file with focused responsibility
```

## Props & Types

### Always type props explicitly and use named props
```typescript
// ✅ GOOD - Named props, destructure in body
interface ProjectCardProps {
  project: Project;
  onDelete?: (id: string) => void;
  className?: string;
}

export const ProjectCard = (props: ProjectCardProps) => {
  const { project, onDelete, className } = props;
  
  // Now you can use project, onDelete, className
  return (
    <div className={className}>
      {project.name}
    </div>
  );
};

// ❌ BAD - Destructuring in parameters
export const ProjectCard = ({ project, onDelete, className }: ProjectCardProps) => {
  // Less clear, harder to refactor
};

// ❌ BAD - No types
export const ProjectCard = (props) => {
  // Missing types
};
```

### Why Use Named Props?

**Benefits:**
- **Clearer intent**: Easy to see what `props` contains
- **Easier refactoring**: Change prop names without touching the signature
- **Better for testing**: Can easily spread `props` in tests
- **Cleaner diffs**: Adding/removing props doesn't change the function signature line

```typescript
// ✅ Example with benefits
export const UserCard = (props: UserCardProps) => {
  const { user, onEdit, onDelete, isLoading } = props;
  
  // Easy to add conditional destructuring
  const { name, email } = user;
  
  // Easy to pass all props down
  return <BaseCard {...props} />;
};
```

## Custom Hooks

### Always use `params` as parameter name and destructure in body

```typescript
// ✅ GOOD - Use "params" and destructure inside
interface UseGetProjectDetailParams {
  projectId: string;
  enabled?: boolean;
}

export function useGetProjectDetail(params: UseGetProjectDetailParams) {
  const { projectId, enabled = true } = params;
  
  // Hook logic here
  return { projectDetail, isLoading };
}

// ❌ BAD - Destructuring in parameters
export function useGetProjectDetail({ projectId, enabled = true }: UseGetProjectDetailParams) {
  // Less clear, harder to refactor
}

// ❌ BAD - Different parameter name
export function useGetProjectDetail(options: UseGetProjectDetailParams) {
  // Use "params" consistently
}
```

### Why Use Named Params?

**Benefits:**
- **Consistency**: All hooks follow the same pattern
- **Clearer intent**: Easy to see what parameters the hook accepts
- **Easier refactoring**: Change param names without touching the signature
- **Better for testing**: Can easily spread `params` in tests
- **Cleaner diffs**: Adding/removing params doesn't change the function signature line

```typescript
// ✅ Example with conditional destructuring
export function useGetData(params: UseGetDataParams) {
  const { id, enabled = true, options } = params;
  
  // Easy to add conditional destructuring
  const { retry, refetchInterval } = options || {};
  
  // Easy to pass all params to helper functions
  const queryKey = buildQueryKey(params);
  
  return useQuery({
    queryKey,
    queryFn: () => fetchData(id),
    enabled,
  });
}
```

### Hook Parameter Pattern Summary

| Pattern | Use Case | Example |
|---------|----------|---------|
| `params: ParamsType` | Always for hooks | `useGetUser(params: UseGetUserParams)` |
| `props: PropsType` | Always for components | `UserCard(props: UserCardProps)` |

**Note:** This pattern applies to ALL custom hooks, not just data-fetching hooks.

## Event Handlers

```typescript
// ✅ GOOD - Named handlers
const handleRetry = () => {
  refetch();
};

const handleDelete = (id: string) => {
  deleteProject(id);
};

<Button onClick={handleRetry}>Try Again</Button>

// ❌ BAD - Inline anonymous functions for complex logic
<Button onClick={() => {
  // lots of logic here
}}>
```
