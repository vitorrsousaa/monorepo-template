---
description: Clean Architecture patterns for API and SPA modules
globs: apps/{api,spa}/src/**/*.ts
alwaysApply: false
---

# Clean Architecture Patterns

Follow Clean Architecture principles to keep the codebase maintainable and testable.

## Layer Separation

### Domain Layer (Core)
Pure business logic, no dependencies on frameworks:

```typescript
// ✅ GOOD - Pure domain entity
export interface Project {
  id: string;
  userId: string;
  name: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}
```

### Application Layer (Use Cases)
```typescript
// ✅ GOOD - Service with clear dependencies
export class GetAllProjectsService {
  constructor(private readonly projectRepository: ProjectRepository) {}

  async execute(userId: string): Promise<Project[]> {
    return await this.projectRepository.getAllProjectsByUser(userId);
  }
}
```

### Infrastructure Layer
Database-specific implementations:

```typescript
// ✅ GOOD - Repository implementation
export class ProjectDynamoRepository implements ProjectRepository {
  constructor(private readonly mapper: ProjectMapper) {}

  async getAllProjectsByUser(userId: string): Promise<Project[]> {
    // DynamoDB specific code here
  }
}
```

## API Module Structure

```
module/
├── controllers/          # HTTP handlers
│   └── get-all-projects/
│       ├── controller.ts
│       ├── schema.ts     # Validation schemas
│       └── index.ts
├── services/            # Business logic
│   └── get-all-projects/
│       ├── service.ts
│       ├── dto.ts       # Data Transfer Objects
│       └── index.ts
└── entities/            # Domain entities
    └── project.ts
```

## SPA Module Structure

```
module/
├── app/
│   ├── entities/        # Domain entities
│   ├── hooks/          # React Query hooks
│   └── services/       # API calls
└── view/
    ├── components/     # UI components
    ├── modals/        # Modal components
    └── pages/         # Page components
```

## Dependency Rule

**Dependencies flow inward**: outer layers can depend on inner layers, never the reverse.

```
View Layer → App Layer → Domain Layer
     ↓            ↓            ↑
Controllers → Services → Entities
     ↓            ↓
Infrastructure (DB, HTTP, etc.)
```

## Data Transformation

Use mappers to convert between layers:

```typescript
// ✅ GOOD - Mapper pattern
export class ProjectMapper {
  toDomain(dbEntity: ProjectDynamoDBEntity): Project {
    return {
      id: dbEntity.id,
      userId: dbEntity.user_id,
      name: dbEntity.name,
      // ... convert from DB format to domain
    };
  }

  toDatabase(project: Project): ProjectDynamoDBEntity {
    return {
      PK: `USER#${project.userId}`,
      SK: `PROJECT#${project.id}`,
      user_id: project.userId,
      // ... convert from domain to DB format
    };
  }
}
```

## Dependency Injection

Use factories to construct and inject dependencies. Factories are pure functions that create and wire up instances.

### Factory Function Pattern

**ALWAYS follow this exact pattern:**

```typescript
// ✅ GOOD - Standard factory pattern
export function makeCreateProjectService(): ICreateProjectService {
  const projectRepository = makeProjectDynamoRepository();

  return new CreateProjectService(projectRepository);
}
```

### Factory Rules

1. **Naming Convention:**
   - Always start with `make` prefix
   - Use camelCase after `make`
   - Example: `makeCreateProjectService`, `makeProjectDynamoRepository`

2. **Return Type:**
   - ALWAYS specify explicit return type
   - Use interface type (e.g., `ICreateProjectService`) when available
   - Use concrete type if no interface exists

3. **Structure:**
   ```typescript
   export function make[Name](): [Type] {
     // 1. Inject dependencies (call other factories)
     const dependency = makeDependency();
     
     // 2. Empty line for readability
     
     // 3. Return new instance with dependencies
     return new [Class](dependency);
   }
   ```

4. **Dependency Order:**
   - Infrastructure first (repositories, mappers)
   - Services next
   - Controllers last

### Examples

#### Service Factory

```typescript
// ✅ GOOD - Service factory
export function makeGetAllProjectsByUserService(): IGetAllProjectsByUserService {
  const projectRepository = makeProjectDynamoRepository();

  return new GetAllProjectsByUserService(projectRepository);
}
```

#### Controller Factory

```typescript
// ✅ GOOD - Controller factory
export function makeGetAllProjectsByUserController(): IGetAllProjectsByUserController {
  const getAllProjectsByUserService = makeGetAllProjectsByUserService();

  return new GetAllProjectsByUserController(getAllProjectsByUserService);
}
```

#### Repository Factory

```typescript
// ✅ GOOD - Repository factory
export function makeProjectDynamoRepository(): ProjectRepository {
  const mapper = new ProjectDynamoMapper();

  return new ProjectDynamoRepository(mapper);
}
```

### Factory Benefits

1. **Centralized Dependency Management:** All wiring in one place
2. **Easy to Test:** Mock factories return test doubles
3. **Type Safety:** Explicit return types catch errors early
4. **Consistent Pattern:** Same structure everywhere
5. **Refactoring Friendly:** Change implementation in one place

### Bad Examples

```typescript
// ❌ BAD - No return type
export function makeCreateProjectService() {
  return new CreateProjectService(makeProjectDynamoRepository());
}

// ❌ BAD - Inline dependency creation
export function makeCreateProjectService(): ICreateProjectService {
  return new CreateProjectService(
    new ProjectDynamoRepository(new ProjectDynamoMapper())
  );
}

// ❌ BAD - Wrong naming convention
export function createProjectServiceFactory(): ICreateProjectService {
  const projectRepository = makeProjectDynamoRepository();
  return new CreateProjectService(projectRepository);
}

// ❌ BAD - No empty line for readability
export function makeCreateProjectService(): ICreateProjectService {
  const projectRepository = makeProjectDynamoRepository();
  return new CreateProjectService(projectRepository);
}
```

## Testing Benefits

This structure makes testing easier:

```typescript
// ✅ Easy to test with mocks
const mockRepository: ProjectRepository = {
  getAllProjectsByUser: jest.fn().mockResolvedValue([]),
};

const service = new GetAllProjectsService(mockRepository);
const result = await service.execute("user-123");
```
